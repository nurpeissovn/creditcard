package main

import (
	"encoding/binary"
	"fmt"
	"os"
)

type BMPFileHeader struct {
	MagicNumber [2]byte
	FileSize    int
	HeaderSize  int
}
type DibHeader struct {
	DibHeaderSize   int
	WidthInPixels   int
	HeightInPixels  int
	PixelSizeInBits int
}

// var (
// 	reader BMPFileHeader
// 	Dib    DibHeader
// )

func main() {
	file, err := os.Open("full.bmp")
	if err != nil {
		fmt.Println(err)
		return
	}
	raw := make([][][3]byte, 360)
	header := make([]byte, 54)
	file.Read(header)
	height := int(binary.LittleEndian.Uint32(header[22:26]))
	width := int(binary.LittleEndian.Uint32(header[18:22]))
	for i := 0; i < height; i++ {
		k := 0
		coloumn := make([]byte, width*3)
		file.Read(coloumn)
		raw[i] = make([][3]byte, width)
		for j := 0; j < len(coloumn); j += 3 {
			raw[i][k][0] = coloumn[j]
			raw[i][k][1] = coloumn[j+1]
			raw[i][k][2] = coloumn[j+2]
			k++

		}

	}
	// fmt.Println(raw[0][0:5][0])
	// for i := 0; i <= 0; i++ {
	// 	for j := 0; j < 480; j++ {
	// 		raw[i][j][0] = 0
	// 		raw[i][j][1] = 0
	// 		raw[i][j][2] = 0

	// 	}
	// }
	// temp := raw[0:2]
	// fmt.Println(temp[0][0:5])
	// fmt.Println(raw[0][0:5])

	// for i := range raw {
	// 	for j := 0; j < width/2; j++ {
	// 		raw[i][j], raw[i][width-1-j] = raw[i][width-1-j], raw[i][j]

	// 	}

	// }
	// for i, j := 0, height-1; i < height/2 && j > height/2; i, j = i+1, j-1 {
	// 	raw[i], raw[j] = raw[j], raw[i]
	// }
	// var r byte
	// var g byte
	// var b byte
	sumR := 0
	sumG := 0
	sumB := 0

	// fmt.Println(r, " ", raw[0][0:3])
	// r += raw[0][0][0]
	// r += raw[0][1][0]
	// r += raw[0][2][0]

	// fmt.Println(r)
	count := 0
	// fmt.Println(raw[0][0][1])
	for i := 0; i < height; i += 5 {
		for j := 0; j < width; j += 5 {
			for a := i; a < i+5; a++ {
				for n := j; n < j+5; n++ {
					sumR += int(raw[a][n][0])
					sumG += int(raw[a][n][1])
					sumB += int(raw[a][n][2])
					count++

				}
			}
			fmt.Print(count, " ")
			avgR := byte(sumR / count)
			avgG := byte(sumG / count)
			avgB := byte(sumB / count)
			// fmt.Print(r/100, " ")
			for a := i; a < i+5; a++ {
				for n := j; n < j+5; n++ {
					raw[a][n][0] = avgR
					raw[a][n][1] = avgG
					raw[a][n][2] = avgB

				}
			}
			count = 0

		}
		// bir := 0
		// eki := 0
		// rotated := make([][][3]byte, width)
		// for i := 0; i < width/3; i++ {
		// 	rotated[i] = make([][3]byte, height*3)

		// }

		// for i := 0; i < width-10; i++ {
		// 	fmt.Print(height, "b", width)

		// 	for j := height - 2; j >= 0; j-- {
		// 		rotated[i][j] = raw[bir][eki]

		// 		fmt.Print(eki, " ")
		// 		bir++
		// 	}
		// 	bir = 0
		// 	eki++

		// }

		res, _ := os.Create("koreik.bmp")
		res.Write(header)
		for i := range raw {
			for j := range raw[i] {
				res.Write(raw[i][j][:])
			}
		}

	}

	// func block() {
}





rotated := make([][][3]byte, len(raw[0]))
	for i := range rotated {
		rotated[i] = make([][3]byte, len(raw))
	}
	for i := range rotated {
		for j := range rotated[i] {
			rotated[i][j] = raw[j][i]
		}
	}
	raw = rotated

	binary.LittleEndian.PutUint32(header[18:22], uint32(len(raw[0])))

	binary.LittleEndian.PutUint32(header[22:26], uint32(len(raw)))

	res, _ := os.Create("koreik.bmp")
	res.Write(header)
	for i := range raw {
		for j := range raw[i] {
			res.Write(raw[i][j][:])
		}
	}
